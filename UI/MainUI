package com.logistica.ui;

import com.logistica.Model.*;
import com.logistica.alg.*;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.nio.file.Path;
import java.util.*;
import java.util.List;

// Interface principal do sistema de Logística e Grafos.
public class MainUI extends JFrame {

    private Graph graph;
    private JTextArea output;
    private JComboBox<String> cbSource, cbTarget;
    private JSpinner spVehicles;
    private JSpinner spAlpha, spBeta;
    private GraphPanel drawPanel;
    private File lastLoadedFolder = null;

    // Cost model (same used in VRPSimulator)
    private static final double R_PER_KM = 1.20;
    private static final double R_PER_MIN = 0.40;

    // road factor must match Dijkstra/VRP
    private static final double ROAD_FACTOR = 1.6;

    public MainUI() {
        super("Planejamento de Logística e Transporte - Grafos (Marabá)");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(1100, 700);
        setLocationRelativeTo(null);
        initComponents();
    }

    private void initComponents() {
        JPanel top = new JPanel(new FlowLayout(FlowLayout.LEFT));

        JButton btnLoad = new JButton("Carregar CSV (pasta)");
        btnLoad.addActionListener(e -> loadCsv());
        top.add(btnLoad);

        cbSource = new JComboBox<>();
        cbTarget = new JComboBox<>();
        top.add(new JLabel("Origem:"));
        top.add(cbSource);
        top.add(new JLabel("Destino:"));
        top.add(cbTarget);

        spAlpha = new JSpinner(new SpinnerNumberModel(1.0, 0.0, 10.0, 0.1));
        spBeta = new JSpinner(new SpinnerNumberModel(0.0, 0.0, 10.0, 0.1));
        top.add(new JLabel("α (tempo):"));
        top.add(spAlpha);
        top.add(new JLabel("β (custo):"));
        top.add(spBeta);

        JButton btnDij = new JButton("Dijkstra");
        btnDij.addActionListener(e -> runDijkstra());
        top.add(btnDij);

        JButton btnBFS = new JButton("BFS");
        btnBFS.addActionListener(e -> runBFS());
        top.add(btnBFS);

        JButton btnDFS = new JButton("DFS");
        btnDFS.addActionListener(e -> runDFS());
        top.add(btnDFS);

        spVehicles = new JSpinner(new SpinnerNumberModel(2, 1, 50, 1));
        top.add(new JLabel("Veículos:"));
        top.add(spVehicles);

        JButton btnVRP = new JButton("Rodar VRP");
        btnVRP.addActionListener(e -> runVRP());
        top.add(btnVRP);

        JButton btnBlock = new JButton("Simular Bloqueio (remover aresta)");
        btnBlock.addActionListener(e -> simulateBlock());
        top.add(btnBlock);

        JButton btnDraw = new JButton("Desenhar Grafo");
        btnDraw.addActionListener(e -> {
            if (graph != null) drawPanel.setGraph(graph);
        });
        top.add(btnDraw);

        output = new JTextArea();
        output.setEditable(false);
        JScrollPane sp = new JScrollPane(output);

        drawPanel = new GraphPanel();

        JSplitPane split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, drawPanel, sp);
        split.setDividerLocation(650);

        getContentPane().setLayout(new BorderLayout());
        getContentPane().add(top, BorderLayout.NORTH);
        getContentPane().add(split, BorderLayout.CENTER);
    }

    private void loadCsv() {
        JFileChooser fc = new JFileChooser();
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        int ret = fc.showOpenDialog(this);
        if (ret != JFileChooser.APPROVE_OPTION) return;

        File dir = fc.getSelectedFile();
        lastLoadedFolder = dir;

        try {
            graph = Graph.loadFromFolder(Path.of(dir.getAbsolutePath()), false);
            refreshNodeCombos();
            drawPanel.setGraph(graph);

            // Mensagem de sucesso + diagnósticos do grafo
            StringBuilder sb = new StringBuilder();
            sb.append("Grafo carregado com sucesso.\n");
            sb.append("Nós: ").append(graph.getNodes().size()).append("\n");
            showGraphDiagnostics(graph, sb);

            output.setText(sb.toString());

        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(this,
                    "Erro ao ler CSV: " + ex.getMessage(),
                    "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void refreshNodeCombos() {
        cbSource.removeAllItems();
        cbTarget.removeAllItems();
        List<Node> nodes = new ArrayList<>(graph.getNodes());
        nodes.sort(Comparator.comparingInt(Node::getId));

        for (Node n : nodes) {
            String s = n.getId() + " - " + n.getLabel();
            cbSource.addItem(s);
            cbTarget.addItem(s);
        }
    }

    private int parseCombo(JComboBox<String> cb) {
        if (cb.getSelectedItem() == null) return -1;
        String s = (String) cb.getSelectedItem();
        return Integer.parseInt(s.split("\\s+")[0]);
    }

    /**
     * Executa Dijkstra e exibe tempo (min), distância (km), distância ajustada e custo estimado (R$).
     */
    private void runDijkstra() {
        if (graph == null) {
            JOptionPane.showMessageDialog(this, "Carregue o grafo primeiro");
            return;
        }

        int src = parseCombo(cbSource);
        int tgt = parseCombo(cbTarget);
        if (src < 0 || tgt < 0) return;

        double alpha = (double) spAlpha.getValue();
        double beta = (double) spBeta.getValue();

        Dijkstra.Result res = Dijkstra.run(graph, src, alpha, beta);
        List<Integer> path = Dijkstra.reconstruct(res.prev, src, tgt);

        StringBuilder sb = new StringBuilder();
        sb.append("Dijkstra (α=").append(alpha).append(", β=").append(beta).append(")\n");
        sb.append("Origem=").append(src).append(" Destino=").append(tgt).append("\n");

        Double dist = res.dist.get(tgt);
        if (dist == null || Double.isInfinite(dist) || path == null || path.isEmpty()) {
            sb.append("Destino inacessível.\n");
            output.setText(sb.toString());
            return;
        } else {
            double t = 0.0;
            double km = 0.0;

            for (int i = 1; i < path.size(); i++) {
                Edge e = findEdge(graph, path.get(i - 1), path.get(i));
                if (e != null) {
                    t += e.getTime();

                    // Prefer distanceKm; se não disponível, inferir via costReais / costPerKm
                    double edgeKm = e.getDistanceKm();
                    if (Double.isNaN(edgeKm)) {
                        double costPerKm = graph.getCostPerKm() == 0.0 ? 1.0 : graph.getCostPerKm();
                        double costReais = e.getCostReais();
                        if (!Double.isNaN(costReais)) {
                            edgeKm = costReais / costPerKm;
                        }
                    }
                    if (Double.isNaN(edgeKm)) edgeKm = 0.0;

                    km += edgeKm;
                }
            }

            double adjustedKm = km * ROAD_FACTOR;
            double money = adjustedKm * R_PER_KM + t * R_PER_MIN;

            sb.append("Custo ponderado: ").append(String.format("%.2f", dist)).append("\n");
            sb.append(String.format("Tempo real: %.2f min\n", t));
            sb.append(String.format("Distância (grafo): %.2f km\n", km));
            sb.append(String.format("Distância ajustada: %.2f km\n", adjustedKm));
            sb.append(String.format("Custo estimado: R$ %.2f\n", money));
            sb.append("Caminho: ").append(path).append("\n");

            output.setText(sb.toString());
            drawPanel.highlightPath(path);
        }
    }

    private void runBFS() {
        if (graph == null) return;
        int src = parseCombo(cbSource);
        var order = BFS.run(graph, src);
        output.setText("BFS ordem: " + order);
    }

    private void runDFS() {
        if (graph == null) return;
        int src = parseCombo(cbSource);
        var order = DFS.run(graph, src);
        output.setText("DFS ordem: " + order);
    }

    /**
     * Executa VRP e exibe para cada veículo: tempo (min), distância (km), distância ajustada e custo (R$).
     */
    private void runVRP() {
        if (graph == null) return;

        int depot = 0;
        List<Integer> customers = new ArrayList<>();
        for (Node n : graph.getNodes())
            if (n.getId() != depot) customers.add(n.getId());

        int vehicles = (Integer) spVehicles.getValue();
        double alpha = (double) spAlpha.getValue();
        double beta = (double) spBeta.getValue();

        var res = VRPSimulator.run(graph, depot, customers, vehicles, alpha, beta);

        StringBuilder sb = new StringBuilder();
        int i = 1;
        double totalTime = 0.0, totalKm = 0.0, totalAdjusted = 0.0, totalMoney = 0.0;
        for (var r : res.routes) {
            totalTime += r.totalTime;
            totalKm += r.totalKm;
            totalAdjusted += r.adjustedKm;
            totalMoney += r.totalMoney;

            sb.append(String.format("Veículo %d:\n", i++));
            sb.append(String.format("  Tempo: %.2f min\n", r.totalTime));
            sb.append(String.format("  Distância (grafo): %.2f km\n", r.totalKm));
            sb.append(String.format("  Distância ajustada: %.2f km\n", r.adjustedKm));
            sb.append(String.format("  Custo: R$ %.2f\n\n", r.totalMoney));
        }

        sb.append(String.format("Tempo total: %.2f min\n", totalTime));
        sb.append(String.format("Distância total (grafo): %.2f km\n", totalKm));
        sb.append(String.format("Distância total ajustada: %.2f km\n", totalAdjusted));
        sb.append(String.format("Custo total: R$ %.2f\n", totalMoney));

        output.setText(sb.toString());
        drawPanel.showRoutes(res.routes);
    }

    private void simulateBlock() {
        if (graph == null) return;

        String input = JOptionPane.showInputDialog(this,
                "Digite a aresta para bloquear (from,to)");

        if (input == null || input.trim().isEmpty()) return;

        try {
            String[] p = input.split(",");
            int a = Integer.parseInt(p[0].trim());
            int b = Integer.parseInt(p[1].trim());

            // remove a aresta (sem salvar para restauração)
            graph.removeEdge(a, b);

            output.setText("Aresta removida: " + a + " -> " + b);
            drawPanel.repaint();
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this,
                    "Formato inválido: " + ex.getMessage());
        }
    }

    private void showGraphDiagnostics(Graph g, StringBuilder sb) {
        if (g == null) return;

        sb.append(GraphUtils.summary(g)).append("\n");

        List<List<Integer>> comps = GraphUtils.connectedComponents(g);
        sb.append("Número de componentes: ").append(comps.size()).append("\n");

        for (int i = 0; i < comps.size(); i++) {
            List<Integer> c = comps.get(i);
            sb.append(String.format("  Componente %d (size=%d): %s\n", i, c.size(), c));
        }

        List<Integer> isolated = GraphUtils.isolatedNodes(g);
        if (!isolated.isEmpty()) {
            sb.append("Vértices isolados: ").append(isolated).append("\n");
        } else {
            sb.append("Vértices isolados: nenhum\n");
        }

        boolean hasCycle = g.isDirected() ? GraphUtils.hasCycleDirected(g) : GraphUtils.hasCycleUndirected(g);
        sb.append("Possui ciclos: ").append(hasCycle ? "Sim" : "Não").append("\n");
    }

    private Edge findEdge(Graph g, int a, int b) {
        for (Edge e : g.getAdj(a))
            if (e.getTo() == b) return e;
        return null;
    }

    public static void showUI() {
        SwingUtilities.invokeLater(() -> {
            // modal welcome panel before opening main UI
            final JDialog dlg = new JDialog((Frame) null, "Bem-vindo - Rotas de Entregas", true);
            dlg.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            dlg.setSize(540, 300);
            dlg.setResizable(false);
            dlg.setLocationRelativeTo(null);

            JPanel content = new JPanel(new BorderLayout(8,8));
            content.setBorder(new EmptyBorder(14,14,14,14));

            JLabel title = new JLabel("Rotas de Entregas");
            title.setFont(title.getFont().deriveFont(Font.BOLD, 18f));
            title.setHorizontalAlignment(SwingConstants.CENTER);
            content.add(title, BorderLayout.NORTH);

            JTextArea info = new JTextArea();
            info.setEditable(false);
            info.setLineWrap(true);
            info.setWrapStyleWord(true);
            info.setText("Bem-vindo ao sistema de Rotas de Entregas.\n\n" +
                    "Use este painel para carregar seus dados (nodes.csv / edges.csv) e executar " +
                    "algoritmos (Dijkstra, BFS, DFS, VRP). Clique em \"Abrir interface\" para continuar.");
            info.setBorder(new EmptyBorder(8,8,8,8));
            content.add(info, BorderLayout.CENTER);

            JPanel btns = new JPanel(new FlowLayout(FlowLayout.CENTER));
            JButton open = new JButton("Abrir interface");
            open.addActionListener(e -> dlg.dispose());
            btns.add(open);
            content.add(btns, BorderLayout.SOUTH);

            dlg.setContentPane(content);
            dlg.setVisible(true); // modal

            MainUI ui = new MainUI();
            ui.setVisible(true);
        });
    }

    // ------- inner class GraphPanel -------
    private static class GraphPanel extends JPanel {

        private Graph g;
        private Map<Integer, Point> positions = new HashMap<>();
        private List<Integer> highlightPath = null;
        private java.util.List<VRPSimulator.Route> routes = null;
        private final int MARGIN = 50;

        // Interaction state (zoom/pan)
        private double zoom = 1.0;
        private Point pan = new Point(0,0);
        private Point dragStart = null;
        private Integer hoverNode = null;

        public GraphPanel() {
            setBackground(Color.WHITE);
            this.addComponentListener(new java.awt.event.ComponentAdapter() {
                @Override
                public void componentResized(java.awt.event.ComponentEvent e) {
                    if (g != null) computePositionsAndRepaint();
                }
            });

            // Mouse wheel zoom
            addMouseWheelListener(e -> {
                double delta = -e.getPreciseWheelRotation();
                double factor = Math.pow(1.12, delta);
                zoom *= factor;
                zoom = Math.max(0.2, Math.min(4.0, zoom));
                repaint();
            });

            // Drag to pan
            addMouseListener(new MouseAdapter() {
                @Override public void mousePressed(MouseEvent e) { dragStart = e.getPoint(); }
                @Override public void mouseReleased(MouseEvent e) { dragStart = null; }
            });
            addMouseMotionListener(new MouseAdapter() {
                @Override public void mouseDragged(MouseEvent e) {
                    if (dragStart != null) {
                        Point cur = e.getPoint();
                        pan.translate(cur.x - dragStart.x, cur.y - dragStart.y);
                        dragStart = cur;
                        repaint();
                    }
                }
                @Override public void mouseMoved(MouseEvent e) {
                    if (positions.isEmpty()) return;
                    Point p = e.getPoint();
                    double invZ = 1.0 / zoom;
                    Integer found = null;
                    for (var entry : positions.entrySet()) {
                        Point np = entry.getValue();
                        int dx = (int) ((p.x - pan.x - np.x) * invZ);
                        int dy = (int) ((p.y - pan.y - np.y) * invZ);
                        if (dx*dx + dy*dy <= 16*16) { found = entry.getKey(); break; }
                    }
                    if (!Objects.equals(found, hoverNode)) {
                        hoverNode = found;
                        if (hoverNode != null) setToolTipText("Nó: " + hoverNode);
                        else setToolTipText(null);
                        ToolTipManager.sharedInstance().mouseMoved(e);
                        repaint();
                    }
                }
            });
        }

        public void setGraph(Graph g) {
            this.g = g;
            this.zoom = 1.0; this.pan = new Point(0,0);
            computePositionsAndRepaint();
        }

        private void computePositionsAndRepaint() {
            positions.clear();
            if (g == null) {
                repaint();
                return;
            }

            double minLon = Double.POSITIVE_INFINITY, maxLon = Double.NEGATIVE_INFINITY;
            double minLat = Double.POSITIVE_INFINITY, maxLat = Double.NEGATIVE_INFINITY;
            for (Node n : g.getNodes()) {
                double lon = n.getX(); // x = longitude
                double lat = n.getY(); // y = latitude
                if (Double.isNaN(lon) || Double.isNaN(lat)) continue;
                if (lon < minLon) minLon = lon;
                if (lon > maxLon) maxLon = lon;
                if (lat < minLat) minLat = lat;
                if (lat > maxLat) maxLat = lat;
            }

            // fallback grid se não houver coords válidas
            if (minLon == Double.POSITIVE_INFINITY || minLat == Double.POSITIVE_INFINITY) {
                int i = 0;
                for (Node n : g.getNodes()) {
                    int px = MARGIN + (i % 10) * 50;
                    int py = MARGIN + (i / 10) * 50;
                    positions.put(n.getId(), new Point(px, py));
                    i++;
                }
                repaint();
                return;
            }

            double spanLon = maxLon - minLon;
            double spanLat = maxLat - minLat;
            if (Math.abs(spanLon) < 1e-9) spanLon = 1e-6;
            if (Math.abs(spanLat) < 1e-9) spanLat = 1e-6;

            int W = Math.max(100, getWidth());
            int H = Math.max(100, getHeight());
            double scaleX = (W - 2.0 * MARGIN) / spanLon;
            double scaleY = (H - 2.0 * MARGIN) / spanLat;
            double scale = Math.min(scaleX, scaleY);

            for (Node n : g.getNodes()) {
                double lon = n.getX();
                double lat = n.getY();
                if (Double.isNaN(lon) || Double.isNaN(lat)) continue;
                int px = (int) Math.round((lon - minLon) * scale + MARGIN);
                int py = (int) Math.round((maxLat - lat) * scale + MARGIN); // invert latitude for screen Y
                positions.put(n.getId(), new Point(px, py));
            }

            repaint();
        }

        public void highlightPath(List<Integer> path) {
            this.highlightPath = path;
            this.routes = null;
            repaint();
        }

        public void showRoutes(List<VRPSimulator.Route> routes) {
            this.routes = routes;
            this.highlightPath = null;
            repaint();
        }

        public void centerOnGraph() {
            // simple center: reset pan and zoom
            this.zoom = 1.0; this.pan = new Point(0,0);
            repaint();
        }

        public void fitToGraph() {
            // For now, reset zoom and pan; advanced fit could compute best zoom to fit all points
            this.zoom = 1.0; this.pan = new Point(0,0);
            repaint();
        }

        @Override
        protected void paintComponent(Graphics g0) {
            super.paintComponent(g0);
            Graphics2D g2 = (Graphics2D) g0.create();
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            if (g == null || this.g == null) {
                g2.setColor(Color.DARK_GRAY);
                g2.drawString("Carregue um grafo (nodes.csv / edges.csv) usando o botão acima.", 20, 20);
                g2.dispose();
                return;
            }

            // apply pan/zoom transform
            g2.translate(pan.x, pan.y);
            g2.scale(zoom, zoom);

            // draw baseline edges
            g2.setStroke(new BasicStroke(1));
            g2.setColor(Color.LIGHT_GRAY);
            for (int u : this.g.getNodeIds()) {
                Point p1 = positions.get(u);
                if (p1 == null) continue;
                for (var e : this.g.getAdj(u)) {
                    Point p2 = positions.get(e.getTo());
                    if (p2 == null) continue;
                    g2.drawLine(p1.x, p1.y, p2.x, p2.y);
                }
            }

            // highlighted path (use a strong color)
            if (highlightPath != null && highlightPath.size() >= 2) {
                g2.setColor(new Color(220, 90, 50)); // vibrant coral
                g2.setStroke(new BasicStroke(3));
                for (int i = 1; i < highlightPath.size(); i++) {
                    Point a = positions.get(highlightPath.get(i - 1));
                    Point b = positions.get(highlightPath.get(i));
                    if (a != null && b != null) g2.drawLine(a.x, a.y, b.x, b.y);
                }
            }

            // routes with vibrant palette
            if (routes != null) {
                Color[] palette = {
                        new Color(0, 122, 255),   // vivid blue
                        new Color(204, 0, 153),   // magenta
                        new Color(255, 115, 0),   // orange
                        new Color(0, 180, 120),   // green
                        new Color(120, 50, 200)   // purple
                };
                int idx = 0;
                for (VRPSimulator.Route r : routes) {
                    g2.setColor(palette[idx % palette.length]);
                    g2.setStroke(new BasicStroke(3));
                    for (int i = 1; i < r.stops.size(); i++) {
                        Point a = positions.get(r.stops.get(i - 1));
                        Point b = positions.get(r.stops.get(i));
                        if (a != null && b != null) g2.drawLine(a.x, a.y, b.x, b.y);
                    }
                    idx++;
                }
            }

            // draw nodes on top (same look as original)
            for (Node n : this.g.getNodes()) {
                Point p = positions.get(n.getId());
                if (p == null) continue;
                g2.setColor(Color.WHITE);
                g2.fillOval(p.x - 12, p.y - 12, 24, 24);
                g2.setColor(Color.BLACK);
                g2.drawOval(p.x - 12, p.y - 12, 24, 24);
                g2.drawString(String.valueOf(n.getId()), p.x - 6, p.y + 4);
            }

            g2.dispose();
        }
    }
}
